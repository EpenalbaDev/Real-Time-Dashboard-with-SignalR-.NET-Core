@page "/dashboard"
@using Microsoft.AspNetCore.SignalR.Client
@using RealTimeDashboard.Data.Entities
@using RealTimeDashboard.Models
@using RealTimeDashboard.Shared.Components
@inject NavigationManager Navigation
@inject ILocalizationService Loc
@implements IAsyncDisposable

<PageTitle>Dashboard</PageTitle>

<div class="dashboard-header">
    <h1>@Loc.Get("dashboard.title")</h1>
    <StatusIndicator State="_connectionState" />
</div>

<!-- Metrics Cards -->
<div class="metrics-grid">
    <MetricsCard Label="@Loc.Get("dashboard.transactions1m")"
                 Value="@_metrics.TotalTransactions1Min.ToString("N0")"
                 SubText="@($"{_metrics.TotalTransactions1Hour:N0} {Loc.Get("dashboard.lastHour")}")"
                 ColorClass="info" />

    <MetricsCard Label="@Loc.Get("dashboard.volume1m")"
                 Value="@_metrics.TotalVolume1Min.ToString("C0")"
                 SubText="@($"{_metrics.TotalVolume1Hour:C0} {Loc.Get("dashboard.lastHour")}")"
                 ColorClass="success" />

    <MetricsCard Label="@Loc.Get("dashboard.tps")"
                 Value="@_metrics.TransactionsPerSecond.ToString("F1")"
                 SubText="@($"{Loc.Get("dashboard.successRate")}: {_metrics.SuccessRate:F1}%")"
                 ColorClass="info" />

    <MetricsCard Label="@Loc.Get("dashboard.flagged")"
                 Value="@_metrics.FlaggedCount.ToString("N0")"
                 SubText="@($"{Loc.Get("dashboard.connections")}: {_metrics.ActiveConnections}")"
                 ColorClass="@(_metrics.FlaggedCount > 0 ? "warning" : "success")" />
</div>

<!-- Main Chart -->
<div class="charts-grid">
    <TransactionChart @ref="_volumeChart" CurrentVolume="@_metrics.TotalVolume1Min" />
</div>

<!-- Side-by-side Charts -->
<div class="charts-row">
    <StatusChart @ref="_statusChart" />
    <SourceChart @ref="_sourceChart" Sources="@_metrics.TopSources" />
</div>

<!-- Recent Transactions Table -->
<TransactionTable Transactions="@_recentTransactions" NewTransactionIds="@_newTxnIds" />

@code {
    [CascadingParameter(Name = "Lang")] public string? Lang { get; set; }

    private HubConnection? _hubConnection;
    private StatusIndicator.ConnectionState _connectionState = StatusIndicator.ConnectionState.Disconnected;

    private DashboardMetricsDto _metrics = new();
    private List<TransactionDto> _recentTransactions = new();
    private HashSet<string> _newTxnIds = new();

    private TransactionChart? _volumeChart;
    private StatusChart? _statusChart;
    private SourceChart? _sourceChart;
    private bool _disposed;

    private const int MaxRecentTransactions = 100;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await StartHubConnectionAsync();
        }
    }

    private async Task StartHubConnectionAsync()
    {
        _connectionState = StatusIndicator.ConnectionState.Connecting;
        await InvokeAsync(StateHasChanged);

        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/hubs/dashboard"))
            .WithAutomaticReconnect(new[]
            {
                TimeSpan.Zero,
                TimeSpan.FromSeconds(2),
                TimeSpan.FromSeconds(5),
                TimeSpan.FromSeconds(10)
            })
            .Build();

        _hubConnection.On<IReadOnlyList<TransactionDto>>("ReceiveTransactionBatch", OnBatchReceived);
        _hubConnection.On<DashboardMetricsDto>("ReceiveMetricsUpdate", OnMetricsReceived);
        _hubConnection.On<AlertDto>("ReceiveAlert", OnAlertReceived);

        _hubConnection.Reconnecting += _ =>
        {
            _connectionState = StatusIndicator.ConnectionState.Reconnecting;
            return InvokeAsync(StateHasChanged);
        };

        _hubConnection.Reconnected += _ =>
        {
            _connectionState = StatusIndicator.ConnectionState.Connected;
            return InvokeAsync(StateHasChanged);
        };

        _hubConnection.Closed += _ =>
        {
            _connectionState = StatusIndicator.ConnectionState.Disconnected;
            return InvokeAsync(StateHasChanged);
        };

        try
        {
            await _hubConnection.StartAsync();
            _connectionState = StatusIndicator.ConnectionState.Connected;
            await InvokeAsync(StateHasChanged);
        }
        catch
        {
            _connectionState = StatusIndicator.ConnectionState.Disconnected;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OnBatchReceived(IReadOnlyList<TransactionDto> batch)
    {
        if (_disposed) return;

        _newTxnIds = new HashSet<string>(batch.Select(t => t.TransactionId));

        // Replace list atomically to avoid collection-modified during rendering
        var updated = new List<TransactionDto>(batch.Count + _recentTransactions.Count);
        updated.AddRange(batch);
        updated.AddRange(_recentTransactions);
        if (updated.Count > MaxRecentTransactions)
            updated.RemoveRange(MaxRecentTransactions, updated.Count - MaxRecentTransactions);
        _recentTransactions = updated;

        try
        {
            await InvokeAsync(StateHasChanged);

            // Clear new highlight after delay
            _ = Task.Delay(1500).ContinueWith(_ =>
            {
                if (_disposed) return;
                _newTxnIds.Clear();
                InvokeAsync(StateHasChanged);
            });
        }
        catch (ObjectDisposedException) { }
    }

    private async Task OnMetricsReceived(DashboardMetricsDto metrics)
    {
        _metrics = metrics;
        await InvokeAsync(StateHasChanged);

        try
        {
            if (_volumeChart is not null)
                await _volumeChart.UpdateAsync(metrics.TotalVolume1Min);

            if (_statusChart is not null)
            {
                // Derive status counts from metrics
                var total = metrics.TotalTransactions1Hour;
                var completed = (int)(total * metrics.SuccessRate / 100.0);
                var failed = (int)(total * metrics.FailureRate / 100.0);
                var flagged = metrics.FlaggedCount;
                var remaining = total - completed - failed - flagged;
                var pending = remaining / 2;
                var processing = remaining - pending;

                await _statusChart.UpdateAsync(completed, pending, processing, failed, flagged);
            }

            if (_sourceChart is not null && metrics.TopSources.Count > 0)
                await _sourceChart.UpdateAsync(metrics.TopSources);
        }
        catch (Exception) when (!_disposed)
        {
            // JS interop can fail during reconnection or disposal
        }
    }

    private Task OnAlertReceived(AlertDto alert)
    {
        // Alerts are visible through the flagged count in metrics
        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        _disposed = true;
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }
}
